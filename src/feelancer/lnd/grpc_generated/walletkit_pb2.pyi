"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import lightning_pb2
import signer_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _AddressType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AddressTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AddressType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _AddressType.ValueType  # 0
    WITNESS_PUBKEY_HASH: _AddressType.ValueType  # 1
    NESTED_WITNESS_PUBKEY_HASH: _AddressType.ValueType  # 2
    HYBRID_NESTED_WITNESS_PUBKEY_HASH: _AddressType.ValueType  # 3
    TAPROOT_PUBKEY: _AddressType.ValueType  # 4

class AddressType(_AddressType, metaclass=_AddressTypeEnumTypeWrapper): ...

UNKNOWN: AddressType.ValueType  # 0
WITNESS_PUBKEY_HASH: AddressType.ValueType  # 1
NESTED_WITNESS_PUBKEY_HASH: AddressType.ValueType  # 2
HYBRID_NESTED_WITNESS_PUBKEY_HASH: AddressType.ValueType  # 3
TAPROOT_PUBKEY: AddressType.ValueType  # 4
global___AddressType = AddressType

class _WitnessType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _WitnessTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WitnessType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN_WITNESS: _WitnessType.ValueType  # 0
    COMMITMENT_TIME_LOCK: _WitnessType.ValueType  # 1
    """
    A witness that allows us to spend the output of a commitment transaction
    after a relative lock-time lockout.
    """
    COMMITMENT_NO_DELAY: _WitnessType.ValueType  # 2
    """
    A witness that allows us to spend a settled no-delay output immediately on a
    counterparty's commitment transaction.
    """
    COMMITMENT_REVOKE: _WitnessType.ValueType  # 3
    """
    A witness that allows us to sweep the settled output of a malicious
    counterparty's who broadcasts a revoked commitment transaction.
    """
    HTLC_OFFERED_REVOKE: _WitnessType.ValueType  # 4
    """
    A witness that allows us to sweep an HTLC which we offered to the remote
    party in the case that they broadcast a revoked commitment state.
    """
    HTLC_ACCEPTED_REVOKE: _WitnessType.ValueType  # 5
    """
    A witness that allows us to sweep an HTLC output sent to us in the case that
    the remote party broadcasts a revoked commitment state.
    """
    HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: _WitnessType.ValueType  # 6
    """
    A witness that allows us to sweep an HTLC output that we extended to a
    party, but was never fulfilled.  This HTLC output isn't directly on the
    commitment transaction, but is the result of a confirmed second-level HTLC
    transaction. As a result, we can only spend this after a CSV delay.
    """
    HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: _WitnessType.ValueType  # 7
    """
    A witness that allows us to sweep an HTLC output that was offered to us, and
    for which we have a payment preimage. This HTLC output isn't directly on our
    commitment transaction, but is the result of confirmed second-level HTLC
    transaction. As a result, we can only spend this after a CSV delay.
    """
    HTLC_OFFERED_REMOTE_TIMEOUT: _WitnessType.ValueType  # 8
    """
    A witness that allows us to sweep an HTLC that we offered to the remote
    party which lies in the commitment transaction of the remote party. We can
    spend this output after the absolute CLTV timeout of the HTLC as passed.
    """
    HTLC_ACCEPTED_REMOTE_SUCCESS: _WitnessType.ValueType  # 9
    """
    A witness that allows us to sweep an HTLC that was offered to us by the
    remote party. We use this witness in the case that the remote party goes to
    chain, and we know the pre-image to the HTLC. We can sweep this without any
    additional timeout.
    """
    HTLC_SECOND_LEVEL_REVOKE: _WitnessType.ValueType  # 10
    """
    A witness that allows us to sweep an HTLC from the remote party's commitment
    transaction in the case that the broadcast a revoked commitment, but then
    also immediately attempt to go to the second level to claim the HTLC.
    """
    WITNESS_KEY_HASH: _WitnessType.ValueType  # 11
    """
    A witness type that allows us to spend a regular p2wkh output that's sent to
    an output which is under complete control of the backing wallet.
    """
    NESTED_WITNESS_KEY_HASH: _WitnessType.ValueType  # 12
    """
    A witness type that allows us to sweep an output that sends to a nested P2SH
    script that pays to a key solely under our control.
    """
    COMMITMENT_ANCHOR: _WitnessType.ValueType  # 13
    """
    A witness type that allows us to spend our anchor on the commitment
    transaction.
    """
    COMMITMENT_NO_DELAY_TWEAKLESS: _WitnessType.ValueType  # 14
    """
    A witness type that is similar to the COMMITMENT_NO_DELAY type,
    but it omits the tweak that randomizes the key we need to
    spend with a channel peer supplied set of randomness.
    """
    COMMITMENT_TO_REMOTE_CONFIRMED: _WitnessType.ValueType  # 15
    """
    A witness type that allows us to spend our output on the counterparty's
    commitment transaction after a confirmation.
    """
    HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED: _WitnessType.ValueType  # 16
    """
    A witness type that allows us to sweep an HTLC output that we extended
    to a party, but was never fulfilled. This _is_ the HTLC output directly
    on our commitment transaction, and the input to the second-level HTLC
    timeout transaction. It can only be spent after CLTV expiry, and
    commitment confirmation.
    """
    HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED: _WitnessType.ValueType  # 17
    """
    A witness type that allows us to sweep an HTLC output that was offered
    to us, and for which we have a payment preimage. This _is_ the HTLC
    output directly on our commitment transaction, and the input to the
    second-level HTLC success transaction. It can only be spent after the
    commitment has confirmed.
    """
    LEASE_COMMITMENT_TIME_LOCK: _WitnessType.ValueType  # 18
    """
    A witness type that allows us to spend our output on our local
    commitment transaction after a relative and absolute lock-time lockout as
    part of the script enforced lease commitment type.
    """
    LEASE_COMMITMENT_TO_REMOTE_CONFIRMED: _WitnessType.ValueType  # 19
    """
    A witness type that allows us to spend our output on the counterparty's
    commitment transaction after a confirmation and absolute locktime as part
    of the script enforced lease commitment type.
    """
    LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: _WitnessType.ValueType  # 20
    """
    A witness type that allows us to sweep an HTLC output that we extended
    to a party, but was never fulfilled. This HTLC output isn't directly on
    the commitment transaction, but is the result of a confirmed second-level
    HTLC transaction. As a result, we can only spend this after a CSV delay
    and CLTV locktime as part of the script enforced lease commitment type.
    """
    LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: _WitnessType.ValueType  # 21
    """
    A witness type that allows us to sweep an HTLC output that was offered
    to us, and for which we have a payment preimage. This HTLC output isn't
    directly on our commitment transaction, but is the result of confirmed
    second-level HTLC transaction. As a result, we can only spend this after
    a CSV delay and CLTV locktime as part of the script enforced lease
    commitment type.
    """
    TAPROOT_PUB_KEY_SPEND: _WitnessType.ValueType  # 22
    """
    A witness type that allows us to spend a regular p2tr output that's sent
    to an output which is under complete control of the backing wallet.
    """
    TAPROOT_LOCAL_COMMIT_SPEND: _WitnessType.ValueType  # 23
    """
    A witness type that allows us to spend our settled local commitment after a
    CSV delay when we force close the channel.
    """
    TAPROOT_REMOTE_COMMIT_SPEND: _WitnessType.ValueType  # 24
    """
    A witness type that allows us to spend our settled local commitment after
    a CSV delay when the remote party has force closed the channel.
    """
    TAPROOT_ANCHOR_SWEEP_SPEND: _WitnessType.ValueType  # 25
    """
    A witness type that we'll use for spending our own anchor output.
    """
    TAPROOT_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: _WitnessType.ValueType  # 26
    """
    A witness that allows us to timeout an HTLC we offered to the remote party
    on our commitment transaction. We use this when we need to go on chain to
    time out an HTLC.
    """
    TAPROOT_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: _WitnessType.ValueType  # 27
    """
    A witness type that allows us to sweep an HTLC we accepted on our commitment
    transaction after we go to the second level on chain.
    """
    TAPROOT_HTLC_SECOND_LEVEL_REVOKE: _WitnessType.ValueType  # 28
    """
    A witness that allows us to sweep an HTLC on the revoked transaction of the
    remote party that goes to the second level.
    """
    TAPROOT_HTLC_ACCEPTED_REVOKE: _WitnessType.ValueType  # 29
    """
    A witness that allows us to sweep an HTLC sent to us by the remote party
    in the event that they broadcast a revoked state.
    """
    TAPROOT_HTLC_OFFERED_REVOKE: _WitnessType.ValueType  # 30
    """
    A witness that allows us to sweep an HTLC we offered to the remote party if
    they broadcast a revoked commitment.
    """
    TAPROOT_HTLC_OFFERED_REMOTE_TIMEOUT: _WitnessType.ValueType  # 31
    """
    A witness that allows us to sweep an HTLC we offered to the remote party
    that lies on the commitment transaction for the remote party. We can spend
    this output after the absolute CLTV timeout of the HTLC as passed.
    """
    TAPROOT_HTLC_LOCAL_OFFERED_TIMEOUT: _WitnessType.ValueType  # 32
    """
    A witness type that allows us to sign the second level HTLC timeout
    transaction when spending from an HTLC residing on our local commitment
    transaction.
    This is used by the sweeper to re-sign inputs if it needs to aggregate
    several second level HTLCs.
    """
    TAPROOT_HTLC_ACCEPTED_REMOTE_SUCCESS: _WitnessType.ValueType  # 33
    """
    A witness that allows us to sweep an HTLC that was offered to us by the
    remote party for a taproot channels. We use this witness in the case that
    the remote party goes to chain, and we know the pre-image to the HTLC. We
    can sweep this without any additional timeout.
    """
    TAPROOT_HTLC_ACCEPTED_LOCAL_SUCCESS: _WitnessType.ValueType  # 34
    """
    A witness type that allows us to sweep the HTLC offered to us on our local
    commitment transaction. We'll use this when we need to go on chain to sweep
    the HTLC. In this case, this is the second level HTLC success transaction.
    """
    TAPROOT_COMMITMENT_REVOKE: _WitnessType.ValueType  # 35
    """
    A witness that allows us to sweep the settled output of a malicious
    counterparty's who broadcasts a revoked taproot commitment transaction.
    """

class WitnessType(_WitnessType, metaclass=_WitnessTypeEnumTypeWrapper): ...

UNKNOWN_WITNESS: WitnessType.ValueType  # 0
COMMITMENT_TIME_LOCK: WitnessType.ValueType  # 1
"""
A witness that allows us to spend the output of a commitment transaction
after a relative lock-time lockout.
"""
COMMITMENT_NO_DELAY: WitnessType.ValueType  # 2
"""
A witness that allows us to spend a settled no-delay output immediately on a
counterparty's commitment transaction.
"""
COMMITMENT_REVOKE: WitnessType.ValueType  # 3
"""
A witness that allows us to sweep the settled output of a malicious
counterparty's who broadcasts a revoked commitment transaction.
"""
HTLC_OFFERED_REVOKE: WitnessType.ValueType  # 4
"""
A witness that allows us to sweep an HTLC which we offered to the remote
party in the case that they broadcast a revoked commitment state.
"""
HTLC_ACCEPTED_REVOKE: WitnessType.ValueType  # 5
"""
A witness that allows us to sweep an HTLC output sent to us in the case that
the remote party broadcasts a revoked commitment state.
"""
HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: WitnessType.ValueType  # 6
"""
A witness that allows us to sweep an HTLC output that we extended to a
party, but was never fulfilled.  This HTLC output isn't directly on the
commitment transaction, but is the result of a confirmed second-level HTLC
transaction. As a result, we can only spend this after a CSV delay.
"""
HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: WitnessType.ValueType  # 7
"""
A witness that allows us to sweep an HTLC output that was offered to us, and
for which we have a payment preimage. This HTLC output isn't directly on our
commitment transaction, but is the result of confirmed second-level HTLC
transaction. As a result, we can only spend this after a CSV delay.
"""
HTLC_OFFERED_REMOTE_TIMEOUT: WitnessType.ValueType  # 8
"""
A witness that allows us to sweep an HTLC that we offered to the remote
party which lies in the commitment transaction of the remote party. We can
spend this output after the absolute CLTV timeout of the HTLC as passed.
"""
HTLC_ACCEPTED_REMOTE_SUCCESS: WitnessType.ValueType  # 9
"""
A witness that allows us to sweep an HTLC that was offered to us by the
remote party. We use this witness in the case that the remote party goes to
chain, and we know the pre-image to the HTLC. We can sweep this without any
additional timeout.
"""
HTLC_SECOND_LEVEL_REVOKE: WitnessType.ValueType  # 10
"""
A witness that allows us to sweep an HTLC from the remote party's commitment
transaction in the case that the broadcast a revoked commitment, but then
also immediately attempt to go to the second level to claim the HTLC.
"""
WITNESS_KEY_HASH: WitnessType.ValueType  # 11
"""
A witness type that allows us to spend a regular p2wkh output that's sent to
an output which is under complete control of the backing wallet.
"""
NESTED_WITNESS_KEY_HASH: WitnessType.ValueType  # 12
"""
A witness type that allows us to sweep an output that sends to a nested P2SH
script that pays to a key solely under our control.
"""
COMMITMENT_ANCHOR: WitnessType.ValueType  # 13
"""
A witness type that allows us to spend our anchor on the commitment
transaction.
"""
COMMITMENT_NO_DELAY_TWEAKLESS: WitnessType.ValueType  # 14
"""
A witness type that is similar to the COMMITMENT_NO_DELAY type,
but it omits the tweak that randomizes the key we need to
spend with a channel peer supplied set of randomness.
"""
COMMITMENT_TO_REMOTE_CONFIRMED: WitnessType.ValueType  # 15
"""
A witness type that allows us to spend our output on the counterparty's
commitment transaction after a confirmation.
"""
HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED: WitnessType.ValueType  # 16
"""
A witness type that allows us to sweep an HTLC output that we extended
to a party, but was never fulfilled. This _is_ the HTLC output directly
on our commitment transaction, and the input to the second-level HTLC
timeout transaction. It can only be spent after CLTV expiry, and
commitment confirmation.
"""
HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED: WitnessType.ValueType  # 17
"""
A witness type that allows us to sweep an HTLC output that was offered
to us, and for which we have a payment preimage. This _is_ the HTLC
output directly on our commitment transaction, and the input to the
second-level HTLC success transaction. It can only be spent after the
commitment has confirmed.
"""
LEASE_COMMITMENT_TIME_LOCK: WitnessType.ValueType  # 18
"""
A witness type that allows us to spend our output on our local
commitment transaction after a relative and absolute lock-time lockout as
part of the script enforced lease commitment type.
"""
LEASE_COMMITMENT_TO_REMOTE_CONFIRMED: WitnessType.ValueType  # 19
"""
A witness type that allows us to spend our output on the counterparty's
commitment transaction after a confirmation and absolute locktime as part
of the script enforced lease commitment type.
"""
LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: WitnessType.ValueType  # 20
"""
A witness type that allows us to sweep an HTLC output that we extended
to a party, but was never fulfilled. This HTLC output isn't directly on
the commitment transaction, but is the result of a confirmed second-level
HTLC transaction. As a result, we can only spend this after a CSV delay
and CLTV locktime as part of the script enforced lease commitment type.
"""
LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: WitnessType.ValueType  # 21
"""
A witness type that allows us to sweep an HTLC output that was offered
to us, and for which we have a payment preimage. This HTLC output isn't
directly on our commitment transaction, but is the result of confirmed
second-level HTLC transaction. As a result, we can only spend this after
a CSV delay and CLTV locktime as part of the script enforced lease
commitment type.
"""
TAPROOT_PUB_KEY_SPEND: WitnessType.ValueType  # 22
"""
A witness type that allows us to spend a regular p2tr output that's sent
to an output which is under complete control of the backing wallet.
"""
TAPROOT_LOCAL_COMMIT_SPEND: WitnessType.ValueType  # 23
"""
A witness type that allows us to spend our settled local commitment after a
CSV delay when we force close the channel.
"""
TAPROOT_REMOTE_COMMIT_SPEND: WitnessType.ValueType  # 24
"""
A witness type that allows us to spend our settled local commitment after
a CSV delay when the remote party has force closed the channel.
"""
TAPROOT_ANCHOR_SWEEP_SPEND: WitnessType.ValueType  # 25
"""
A witness type that we'll use for spending our own anchor output.
"""
TAPROOT_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: WitnessType.ValueType  # 26
"""
A witness that allows us to timeout an HTLC we offered to the remote party
on our commitment transaction. We use this when we need to go on chain to
time out an HTLC.
"""
TAPROOT_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: WitnessType.ValueType  # 27
"""
A witness type that allows us to sweep an HTLC we accepted on our commitment
transaction after we go to the second level on chain.
"""
TAPROOT_HTLC_SECOND_LEVEL_REVOKE: WitnessType.ValueType  # 28
"""
A witness that allows us to sweep an HTLC on the revoked transaction of the
remote party that goes to the second level.
"""
TAPROOT_HTLC_ACCEPTED_REVOKE: WitnessType.ValueType  # 29
"""
A witness that allows us to sweep an HTLC sent to us by the remote party
in the event that they broadcast a revoked state.
"""
TAPROOT_HTLC_OFFERED_REVOKE: WitnessType.ValueType  # 30
"""
A witness that allows us to sweep an HTLC we offered to the remote party if
they broadcast a revoked commitment.
"""
TAPROOT_HTLC_OFFERED_REMOTE_TIMEOUT: WitnessType.ValueType  # 31
"""
A witness that allows us to sweep an HTLC we offered to the remote party
that lies on the commitment transaction for the remote party. We can spend
this output after the absolute CLTV timeout of the HTLC as passed.
"""
TAPROOT_HTLC_LOCAL_OFFERED_TIMEOUT: WitnessType.ValueType  # 32
"""
A witness type that allows us to sign the second level HTLC timeout
transaction when spending from an HTLC residing on our local commitment
transaction.
This is used by the sweeper to re-sign inputs if it needs to aggregate
several second level HTLCs.
"""
TAPROOT_HTLC_ACCEPTED_REMOTE_SUCCESS: WitnessType.ValueType  # 33
"""
A witness that allows us to sweep an HTLC that was offered to us by the
remote party for a taproot channels. We use this witness in the case that
the remote party goes to chain, and we know the pre-image to the HTLC. We
can sweep this without any additional timeout.
"""
TAPROOT_HTLC_ACCEPTED_LOCAL_SUCCESS: WitnessType.ValueType  # 34
"""
A witness type that allows us to sweep the HTLC offered to us on our local
commitment transaction. We'll use this when we need to go on chain to sweep
the HTLC. In this case, this is the second level HTLC success transaction.
"""
TAPROOT_COMMITMENT_REVOKE: WitnessType.ValueType  # 35
"""
A witness that allows us to sweep the settled output of a malicious
counterparty's who broadcasts a revoked taproot commitment transaction.
"""
global___WitnessType = WitnessType

class _ChangeAddressType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ChangeAddressTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ChangeAddressType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CHANGE_ADDRESS_TYPE_UNSPECIFIED: _ChangeAddressType.ValueType  # 0
    """CHANGE_ADDRESS_TYPE_UNSPECIFIED indicates that no change address type is
    provided. We will then use P2WPKH address type for change (BIP0084 key
    scope).
    """
    CHANGE_ADDRESS_TYPE_P2TR: _ChangeAddressType.ValueType  # 1
    """CHANGE_ADDRESS_TYPE_P2TR indicates to use P2TR address for change output
    (BIP0086 key scope).
    """

class ChangeAddressType(_ChangeAddressType, metaclass=_ChangeAddressTypeEnumTypeWrapper):
    """The possible change address types for default accounts and single imported
    public keys. By default, P2WPKH will be used. We don't provide the
    possibility to choose P2PKH as it is a legacy key scope, nor NP2WPKH as
    no key scope permits to do so. For custom accounts, no change type should
    be provided as the coin selection key scope will always be used to generate
    the change address.
    """

CHANGE_ADDRESS_TYPE_UNSPECIFIED: ChangeAddressType.ValueType  # 0
"""CHANGE_ADDRESS_TYPE_UNSPECIFIED indicates that no change address type is
provided. We will then use P2WPKH address type for change (BIP0084 key
scope).
"""
CHANGE_ADDRESS_TYPE_P2TR: ChangeAddressType.ValueType  # 1
"""CHANGE_ADDRESS_TYPE_P2TR indicates to use P2TR address for change output
(BIP0086 key scope).
"""
global___ChangeAddressType = ChangeAddressType

@typing.final
class ListUnspentRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MIN_CONFS_FIELD_NUMBER: builtins.int
    MAX_CONFS_FIELD_NUMBER: builtins.int
    ACCOUNT_FIELD_NUMBER: builtins.int
    UNCONFIRMED_ONLY_FIELD_NUMBER: builtins.int
    min_confs: builtins.int
    """The minimum number of confirmations to be included."""
    max_confs: builtins.int
    """The maximum number of confirmations to be included."""
    account: builtins.str
    """An optional filter to only include outputs belonging to an account."""
    unconfirmed_only: builtins.bool
    """
    When min_confs and max_confs are zero, setting false implicitly
    overrides max_confs to be MaxInt32, otherwise max_confs remains
    zero. An error is returned if the value is true and both min_confs
    and max_confs are non-zero. (default: false)
    """
    def __init__(
        self,
        *,
        min_confs: builtins.int = ...,
        max_confs: builtins.int = ...,
        account: builtins.str = ...,
        unconfirmed_only: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["account", b"account", "max_confs", b"max_confs", "min_confs", b"min_confs", "unconfirmed_only", b"unconfirmed_only"]) -> None: ...

global___ListUnspentRequest = ListUnspentRequest

@typing.final
class ListUnspentResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    UTXOS_FIELD_NUMBER: builtins.int
    @property
    def utxos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[lightning_pb2.Utxo]:
        """A list of utxos satisfying the specified number of confirmations."""

    def __init__(
        self,
        *,
        utxos: collections.abc.Iterable[lightning_pb2.Utxo] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["utxos", b"utxos"]) -> None: ...

global___ListUnspentResponse = ListUnspentResponse

@typing.final
class LeaseOutputRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    OUTPOINT_FIELD_NUMBER: builtins.int
    EXPIRATION_SECONDS_FIELD_NUMBER: builtins.int
    id: builtins.bytes
    """
    An ID of 32 random bytes that must be unique for each distinct application
    using this RPC which will be used to bound the output lease to.
    """
    expiration_seconds: builtins.int
    """The time in seconds before the lock expires. If set to zero, the default
    lock duration is used.
    """
    @property
    def outpoint(self) -> lightning_pb2.OutPoint:
        """The identifying outpoint of the output being leased."""

    def __init__(
        self,
        *,
        id: builtins.bytes = ...,
        outpoint: lightning_pb2.OutPoint | None = ...,
        expiration_seconds: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["outpoint", b"outpoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["expiration_seconds", b"expiration_seconds", "id", b"id", "outpoint", b"outpoint"]) -> None: ...

global___LeaseOutputRequest = LeaseOutputRequest

@typing.final
class LeaseOutputResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPIRATION_FIELD_NUMBER: builtins.int
    expiration: builtins.int
    """
    The absolute expiration of the output lease represented as a unix timestamp.
    """
    def __init__(
        self,
        *,
        expiration: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["expiration", b"expiration"]) -> None: ...

global___LeaseOutputResponse = LeaseOutputResponse

@typing.final
class ReleaseOutputRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    OUTPOINT_FIELD_NUMBER: builtins.int
    id: builtins.bytes
    """The unique ID that was used to lock the output."""
    @property
    def outpoint(self) -> lightning_pb2.OutPoint:
        """The identifying outpoint of the output being released."""

    def __init__(
        self,
        *,
        id: builtins.bytes = ...,
        outpoint: lightning_pb2.OutPoint | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["outpoint", b"outpoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["id", b"id", "outpoint", b"outpoint"]) -> None: ...

global___ReleaseOutputRequest = ReleaseOutputRequest

@typing.final
class ReleaseOutputResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___ReleaseOutputResponse = ReleaseOutputResponse

@typing.final
class KeyReq(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FINGER_PRINT_FIELD_NUMBER: builtins.int
    KEY_FAMILY_FIELD_NUMBER: builtins.int
    key_finger_print: builtins.int
    """
    Is the key finger print of the root pubkey that this request is targeting.
    This allows the WalletKit to possibly serve out keys for multiple HD chains
    via public derivation.
    """
    key_family: builtins.int
    """
    The target key family to derive a key from. In other contexts, this is
    known as the "account".
    """
    def __init__(
        self,
        *,
        key_finger_print: builtins.int = ...,
        key_family: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key_family", b"key_family", "key_finger_print", b"key_finger_print"]) -> None: ...

global___KeyReq = KeyReq

@typing.final
class AddrRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNT_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    CHANGE_FIELD_NUMBER: builtins.int
    account: builtins.str
    """
    The name of the account to retrieve the next address of. If empty, the
    default wallet account is used.
    """
    type: global___AddressType.ValueType
    """
    The type of address to derive.
    """
    change: builtins.bool
    """
    Whether a change address should be derived.
    """
    def __init__(
        self,
        *,
        account: builtins.str = ...,
        type: global___AddressType.ValueType = ...,
        change: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["account", b"account", "change", b"change", "type", b"type"]) -> None: ...

global___AddrRequest = AddrRequest

@typing.final
class AddrResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDR_FIELD_NUMBER: builtins.int
    addr: builtins.str
    """
    The address encoded using a bech32 format.
    """
    def __init__(
        self,
        *,
        addr: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["addr", b"addr"]) -> None: ...

global___AddrResponse = AddrResponse

@typing.final
class Account(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    ADDRESS_TYPE_FIELD_NUMBER: builtins.int
    EXTENDED_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    MASTER_KEY_FINGERPRINT_FIELD_NUMBER: builtins.int
    DERIVATION_PATH_FIELD_NUMBER: builtins.int
    EXTERNAL_KEY_COUNT_FIELD_NUMBER: builtins.int
    INTERNAL_KEY_COUNT_FIELD_NUMBER: builtins.int
    WATCH_ONLY_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name used to identify the account."""
    address_type: global___AddressType.ValueType
    """The type of addresses the account supports."""
    extended_public_key: builtins.str
    """
    The public key backing the account that all keys are derived from
    represented as an extended key. This will always be empty for the default
    imported account in which single public keys are imported into.
    """
    master_key_fingerprint: builtins.bytes
    """
    The fingerprint of the root key from which the account public key was
    derived from. This will always be zero for the default imported account in
    which single public keys are imported into. The bytes are in big-endian
    order.
    """
    derivation_path: builtins.str
    """
    The derivation path corresponding to the account public key. This will
    always be empty for the default imported account in which single public keys
    are imported into.
    """
    external_key_count: builtins.int
    """
    The number of keys derived from the external branch of the account public
    key. This will always be zero for the default imported account in which
    single public keys are imported into.
    """
    internal_key_count: builtins.int
    """
    The number of keys derived from the internal branch of the account public
    key. This will always be zero for the default imported account in which
    single public keys are imported into.
    """
    watch_only: builtins.bool
    """Whether the wallet stores private keys for the account."""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        address_type: global___AddressType.ValueType = ...,
        extended_public_key: builtins.str = ...,
        master_key_fingerprint: builtins.bytes = ...,
        derivation_path: builtins.str = ...,
        external_key_count: builtins.int = ...,
        internal_key_count: builtins.int = ...,
        watch_only: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address_type", b"address_type", "derivation_path", b"derivation_path", "extended_public_key", b"extended_public_key", "external_key_count", b"external_key_count", "internal_key_count", b"internal_key_count", "master_key_fingerprint", b"master_key_fingerprint", "name", b"name", "watch_only", b"watch_only"]) -> None: ...

global___Account = Account

@typing.final
class AddressProperty(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDRESS_FIELD_NUMBER: builtins.int
    IS_INTERNAL_FIELD_NUMBER: builtins.int
    BALANCE_FIELD_NUMBER: builtins.int
    DERIVATION_PATH_FIELD_NUMBER: builtins.int
    PUBLIC_KEY_FIELD_NUMBER: builtins.int
    address: builtins.str
    """
    The address encoded using the appropriate format depending on the
    address type (base58, bech32, bech32m).

    Note that lnd's internal/custom keys for channels and other
    functionality are derived from the same scope. Since they
    aren't really used as addresses and will never have an
    on-chain balance, we'll show the public key instead (only if
    the show_custom_accounts flag is provided).
    """
    is_internal: builtins.bool
    """Denotes if the address is a change address."""
    balance: builtins.int
    """The balance of the address."""
    derivation_path: builtins.str
    """The full derivation path of the address. This will be empty for imported
    addresses.
    """
    public_key: builtins.bytes
    """The public key of the address. This will be empty for imported addresses."""
    def __init__(
        self,
        *,
        address: builtins.str = ...,
        is_internal: builtins.bool = ...,
        balance: builtins.int = ...,
        derivation_path: builtins.str = ...,
        public_key: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "balance", b"balance", "derivation_path", b"derivation_path", "is_internal", b"is_internal", "public_key", b"public_key"]) -> None: ...

global___AddressProperty = AddressProperty

@typing.final
class AccountWithAddresses(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    ADDRESS_TYPE_FIELD_NUMBER: builtins.int
    DERIVATION_PATH_FIELD_NUMBER: builtins.int
    ADDRESSES_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name used to identify the account."""
    address_type: global___AddressType.ValueType
    """The type of addresses the account supports."""
    derivation_path: builtins.str
    """
    The derivation path corresponding to the account public key. This will
    always be empty for the default imported account in which single public keys
    are imported into.
    """
    @property
    def addresses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AddressProperty]:
        """
        List of address, its type internal/external & balance.
        Note that the order of addresses will be random and not according to the
        derivation index, since that information is not stored by the underlying
        wallet.
        """

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        address_type: global___AddressType.ValueType = ...,
        derivation_path: builtins.str = ...,
        addresses: collections.abc.Iterable[global___AddressProperty] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address_type", b"address_type", "addresses", b"addresses", "derivation_path", b"derivation_path", "name", b"name"]) -> None: ...

global___AccountWithAddresses = AccountWithAddresses

@typing.final
class ListAccountsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    ADDRESS_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """An optional filter to only return accounts matching this name."""
    address_type: global___AddressType.ValueType
    """An optional filter to only return accounts matching this address type."""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        address_type: global___AddressType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address_type", b"address_type", "name", b"name"]) -> None: ...

global___ListAccountsRequest = ListAccountsRequest

@typing.final
class ListAccountsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNTS_FIELD_NUMBER: builtins.int
    @property
    def accounts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Account]: ...
    def __init__(
        self,
        *,
        accounts: collections.abc.Iterable[global___Account] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["accounts", b"accounts"]) -> None: ...

global___ListAccountsResponse = ListAccountsResponse

@typing.final
class RequiredReserveRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDITIONAL_PUBLIC_CHANNELS_FIELD_NUMBER: builtins.int
    additional_public_channels: builtins.int
    """The number of additional channels the user would like to open."""
    def __init__(
        self,
        *,
        additional_public_channels: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["additional_public_channels", b"additional_public_channels"]) -> None: ...

global___RequiredReserveRequest = RequiredReserveRequest

@typing.final
class RequiredReserveResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REQUIRED_RESERVE_FIELD_NUMBER: builtins.int
    required_reserve: builtins.int
    """The amount of reserve required."""
    def __init__(
        self,
        *,
        required_reserve: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["required_reserve", b"required_reserve"]) -> None: ...

global___RequiredReserveResponse = RequiredReserveResponse

@typing.final
class ListAddressesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNT_NAME_FIELD_NUMBER: builtins.int
    SHOW_CUSTOM_ACCOUNTS_FIELD_NUMBER: builtins.int
    account_name: builtins.str
    """An optional filter to only return addresses matching this account."""
    show_custom_accounts: builtins.bool
    """An optional flag to return LND's custom accounts (Purpose=1017)
    public key along with other addresses.
    """
    def __init__(
        self,
        *,
        account_name: builtins.str = ...,
        show_custom_accounts: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["account_name", b"account_name", "show_custom_accounts", b"show_custom_accounts"]) -> None: ...

global___ListAddressesRequest = ListAddressesRequest

@typing.final
class ListAddressesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNT_WITH_ADDRESSES_FIELD_NUMBER: builtins.int
    @property
    def account_with_addresses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AccountWithAddresses]:
        """A list of all the accounts and their addresses."""

    def __init__(
        self,
        *,
        account_with_addresses: collections.abc.Iterable[global___AccountWithAddresses] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["account_with_addresses", b"account_with_addresses"]) -> None: ...

global___ListAddressesResponse = ListAddressesResponse

@typing.final
class GetTransactionRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TXID_FIELD_NUMBER: builtins.int
    txid: builtins.str
    """The txid of the transaction."""
    def __init__(
        self,
        *,
        txid: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["txid", b"txid"]) -> None: ...

global___GetTransactionRequest = GetTransactionRequest

@typing.final
class SignMessageWithAddrRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MSG_FIELD_NUMBER: builtins.int
    ADDR_FIELD_NUMBER: builtins.int
    msg: builtins.bytes
    """The message to be signed. When using REST, this field must be encoded as
    base64.
    """
    addr: builtins.str
    """The address which will be used to look up the private key and sign the
    corresponding message.
    """
    def __init__(
        self,
        *,
        msg: builtins.bytes = ...,
        addr: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["addr", b"addr", "msg", b"msg"]) -> None: ...

global___SignMessageWithAddrRequest = SignMessageWithAddrRequest

@typing.final
class SignMessageWithAddrResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIGNATURE_FIELD_NUMBER: builtins.int
    signature: builtins.str
    """The compact ECDSA signature for the given message encoded in base64."""
    def __init__(
        self,
        *,
        signature: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["signature", b"signature"]) -> None: ...

global___SignMessageWithAddrResponse = SignMessageWithAddrResponse

@typing.final
class VerifyMessageWithAddrRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MSG_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    ADDR_FIELD_NUMBER: builtins.int
    msg: builtins.bytes
    """The message to be signed. When using REST, this field must be encoded as
    base64.
    """
    signature: builtins.str
    """The compact ECDSA signature to be verified over the given message
    ecoded in base64.
    """
    addr: builtins.str
    """The address which will be used to look up the public key and verify the
    the signature.
    """
    def __init__(
        self,
        *,
        msg: builtins.bytes = ...,
        signature: builtins.str = ...,
        addr: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["addr", b"addr", "msg", b"msg", "signature", b"signature"]) -> None: ...

global___VerifyMessageWithAddrRequest = VerifyMessageWithAddrRequest

@typing.final
class VerifyMessageWithAddrResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALID_FIELD_NUMBER: builtins.int
    PUBKEY_FIELD_NUMBER: builtins.int
    valid: builtins.bool
    """Whether the signature was valid over the given message."""
    pubkey: builtins.bytes
    """The pubkey recovered from the signature."""
    def __init__(
        self,
        *,
        valid: builtins.bool = ...,
        pubkey: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pubkey", b"pubkey", "valid", b"valid"]) -> None: ...

global___VerifyMessageWithAddrResponse = VerifyMessageWithAddrResponse

@typing.final
class ImportAccountRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    EXTENDED_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    MASTER_KEY_FINGERPRINT_FIELD_NUMBER: builtins.int
    ADDRESS_TYPE_FIELD_NUMBER: builtins.int
    DRY_RUN_FIELD_NUMBER: builtins.int
    name: builtins.str
    """A name to identify the account with."""
    extended_public_key: builtins.str
    """
    A public key that corresponds to a wallet account represented as an extended
    key. It must conform to a derivation path of the form
    m/purpose'/coin_type'/account'.
    """
    master_key_fingerprint: builtins.bytes
    """
    The fingerprint of the root key (also known as the key with derivation path
    m/) from which the account public key was derived from. This may be required
    by some hardware wallets for proper identification and signing. The bytes
    must be in big-endian order.
    """
    address_type: global___AddressType.ValueType
    """
    An address type is only required when the extended account public key has a
    legacy version (xpub, tpub, etc.), such that the wallet cannot detect what
    address scheme it belongs to.
    """
    dry_run: builtins.bool
    """
    Whether a dry run should be attempted when importing the account. This
    serves as a way to confirm whether the account is being imported correctly
    by returning the first N addresses for the external and internal branches of
    the account. If these addresses match as expected, then it should be safe to
    import the account as is.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        extended_public_key: builtins.str = ...,
        master_key_fingerprint: builtins.bytes = ...,
        address_type: global___AddressType.ValueType = ...,
        dry_run: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address_type", b"address_type", "dry_run", b"dry_run", "extended_public_key", b"extended_public_key", "master_key_fingerprint", b"master_key_fingerprint", "name", b"name"]) -> None: ...

global___ImportAccountRequest = ImportAccountRequest

@typing.final
class ImportAccountResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNT_FIELD_NUMBER: builtins.int
    DRY_RUN_EXTERNAL_ADDRS_FIELD_NUMBER: builtins.int
    DRY_RUN_INTERNAL_ADDRS_FIELD_NUMBER: builtins.int
    @property
    def account(self) -> global___Account:
        """The details of the imported account."""

    @property
    def dry_run_external_addrs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """
        The first N addresses that belong to the external branch of the account.
        The external branch is typically used for external non-change addresses.
        These are only returned if a dry run was specified within the request.
        """

    @property
    def dry_run_internal_addrs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """
        The first N addresses that belong to the internal branch of the account.
        The internal branch is typically used for change addresses. These are only
        returned if a dry run was specified within the request.
        """

    def __init__(
        self,
        *,
        account: global___Account | None = ...,
        dry_run_external_addrs: collections.abc.Iterable[builtins.str] | None = ...,
        dry_run_internal_addrs: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["account", b"account"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["account", b"account", "dry_run_external_addrs", b"dry_run_external_addrs", "dry_run_internal_addrs", b"dry_run_internal_addrs"]) -> None: ...

global___ImportAccountResponse = ImportAccountResponse

@typing.final
class ImportPublicKeyRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PUBLIC_KEY_FIELD_NUMBER: builtins.int
    ADDRESS_TYPE_FIELD_NUMBER: builtins.int
    public_key: builtins.bytes
    """A compressed public key represented as raw bytes."""
    address_type: global___AddressType.ValueType
    """The type of address that will be generated from the public key."""
    def __init__(
        self,
        *,
        public_key: builtins.bytes = ...,
        address_type: global___AddressType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address_type", b"address_type", "public_key", b"public_key"]) -> None: ...

global___ImportPublicKeyRequest = ImportPublicKeyRequest

@typing.final
class ImportPublicKeyResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___ImportPublicKeyResponse = ImportPublicKeyResponse

@typing.final
class ImportTapscriptRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERNAL_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    FULL_TREE_FIELD_NUMBER: builtins.int
    PARTIAL_REVEAL_FIELD_NUMBER: builtins.int
    ROOT_HASH_ONLY_FIELD_NUMBER: builtins.int
    FULL_KEY_ONLY_FIELD_NUMBER: builtins.int
    internal_public_key: builtins.bytes
    """
    The internal public key, serialized as 32-byte x-only public key.
    """
    root_hash_only: builtins.bytes
    """
    Only the root hash of the Taproot script tree (or other form of Taproot
    commitment) is known.
    """
    full_key_only: builtins.bool
    """
    Only the final, tweaked Taproot key is known and no additional
    information about the internal key or type of tweak that was used to
    derive it. When this is set, the wallet treats the key in
    internal_public_key as the Taproot key directly. This can be useful for
    tracking arbitrary Taproot outputs without the goal of ever being able
    to spend from them through the internal wallet.
    """
    @property
    def full_tree(self) -> global___TapscriptFullTree:
        """
        The full script tree with all individual leaves is known and the root
        hash can be constructed from the full tree directly.
        """

    @property
    def partial_reveal(self) -> global___TapscriptPartialReveal:
        """
        Only a single script leaf is known. To construct the root hash, the full
        inclusion proof must also be provided.
        """

    def __init__(
        self,
        *,
        internal_public_key: builtins.bytes = ...,
        full_tree: global___TapscriptFullTree | None = ...,
        partial_reveal: global___TapscriptPartialReveal | None = ...,
        root_hash_only: builtins.bytes = ...,
        full_key_only: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["full_key_only", b"full_key_only", "full_tree", b"full_tree", "partial_reveal", b"partial_reveal", "root_hash_only", b"root_hash_only", "script", b"script"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["full_key_only", b"full_key_only", "full_tree", b"full_tree", "internal_public_key", b"internal_public_key", "partial_reveal", b"partial_reveal", "root_hash_only", b"root_hash_only", "script", b"script"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["script", b"script"]) -> typing.Literal["full_tree", "partial_reveal", "root_hash_only", "full_key_only"] | None: ...

global___ImportTapscriptRequest = ImportTapscriptRequest

@typing.final
class TapscriptFullTree(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALL_LEAVES_FIELD_NUMBER: builtins.int
    @property
    def all_leaves(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TapLeaf]:
        """
        The complete, ordered list of all tap leaves of the tree.
        """

    def __init__(
        self,
        *,
        all_leaves: collections.abc.Iterable[global___TapLeaf] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["all_leaves", b"all_leaves"]) -> None: ...

global___TapscriptFullTree = TapscriptFullTree

@typing.final
class TapLeaf(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LEAF_VERSION_FIELD_NUMBER: builtins.int
    SCRIPT_FIELD_NUMBER: builtins.int
    leaf_version: builtins.int
    """The leaf version. Should be 0xc0 (192) in case of a SegWit v1 script."""
    script: builtins.bytes
    """The script of the tap leaf."""
    def __init__(
        self,
        *,
        leaf_version: builtins.int = ...,
        script: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["leaf_version", b"leaf_version", "script", b"script"]) -> None: ...

global___TapLeaf = TapLeaf

@typing.final
class TapscriptPartialReveal(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REVEALED_LEAF_FIELD_NUMBER: builtins.int
    FULL_INCLUSION_PROOF_FIELD_NUMBER: builtins.int
    full_inclusion_proof: builtins.bytes
    """The BIP-0341 serialized inclusion proof that is required to prove that
    the revealed leaf is part of the tree. This contains 0..n blocks of 32
    bytes. If the tree only contained a single leaf (which is the revealed
    leaf), this can be empty.
    """
    @property
    def revealed_leaf(self) -> global___TapLeaf:
        """The tap leaf that is known and will be revealed."""

    def __init__(
        self,
        *,
        revealed_leaf: global___TapLeaf | None = ...,
        full_inclusion_proof: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["revealed_leaf", b"revealed_leaf"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["full_inclusion_proof", b"full_inclusion_proof", "revealed_leaf", b"revealed_leaf"]) -> None: ...

global___TapscriptPartialReveal = TapscriptPartialReveal

@typing.final
class ImportTapscriptResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    P2TR_ADDRESS_FIELD_NUMBER: builtins.int
    p2tr_address: builtins.str
    """
    The resulting pay-to-Taproot address that represents the imported internal
    key with the script committed to it.
    """
    def __init__(
        self,
        *,
        p2tr_address: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["p2tr_address", b"p2tr_address"]) -> None: ...

global___ImportTapscriptResponse = ImportTapscriptResponse

@typing.final
class Transaction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TX_HEX_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    tx_hex: builtins.bytes
    """
    The raw serialized transaction. Despite the field name, this does need to be
    specified in raw bytes (or base64 encoded when using REST) and not in hex.
    To not break existing software, the field can't simply be renamed.
    """
    label: builtins.str
    """
    An optional label to save with the transaction. Limited to 500 characters.
    """
    def __init__(
        self,
        *,
        tx_hex: builtins.bytes = ...,
        label: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["label", b"label", "tx_hex", b"tx_hex"]) -> None: ...

global___Transaction = Transaction

@typing.final
class PublishResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PUBLISH_ERROR_FIELD_NUMBER: builtins.int
    publish_error: builtins.str
    """
    If blank, then no error occurred and the transaction was successfully
    published. If not the empty string, then a string representation of the
    broadcast error.

    TODO(roasbeef): map to a proper enum type
    """
    def __init__(
        self,
        *,
        publish_error: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["publish_error", b"publish_error"]) -> None: ...

global___PublishResponse = PublishResponse

@typing.final
class RemoveTransactionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATUS_FIELD_NUMBER: builtins.int
    status: builtins.str
    """The status of the remove transaction operation."""
    def __init__(
        self,
        *,
        status: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["status", b"status"]) -> None: ...

global___RemoveTransactionResponse = RemoveTransactionResponse

@typing.final
class SendOutputsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAT_PER_KW_FIELD_NUMBER: builtins.int
    OUTPUTS_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    MIN_CONFS_FIELD_NUMBER: builtins.int
    SPEND_UNCONFIRMED_FIELD_NUMBER: builtins.int
    COIN_SELECTION_STRATEGY_FIELD_NUMBER: builtins.int
    sat_per_kw: builtins.int
    """
    The number of satoshis per kilo weight that should be used when crafting
    this transaction.
    """
    label: builtins.str
    """An optional label for the transaction, limited to 500 characters."""
    min_confs: builtins.int
    """The minimum number of confirmations each one of your outputs used for
    the transaction must satisfy.
    """
    spend_unconfirmed: builtins.bool
    """Whether unconfirmed outputs should be used as inputs for the transaction."""
    coin_selection_strategy: lightning_pb2.CoinSelectionStrategy.ValueType
    """The strategy to use for selecting coins during sending the outputs."""
    @property
    def outputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[signer_pb2.TxOut]:
        """
        A slice of the outputs that should be created in the transaction produced.
        """

    def __init__(
        self,
        *,
        sat_per_kw: builtins.int = ...,
        outputs: collections.abc.Iterable[signer_pb2.TxOut] | None = ...,
        label: builtins.str = ...,
        min_confs: builtins.int = ...,
        spend_unconfirmed: builtins.bool = ...,
        coin_selection_strategy: lightning_pb2.CoinSelectionStrategy.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["coin_selection_strategy", b"coin_selection_strategy", "label", b"label", "min_confs", b"min_confs", "outputs", b"outputs", "sat_per_kw", b"sat_per_kw", "spend_unconfirmed", b"spend_unconfirmed"]) -> None: ...

global___SendOutputsRequest = SendOutputsRequest

@typing.final
class SendOutputsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAW_TX_FIELD_NUMBER: builtins.int
    raw_tx: builtins.bytes
    """
    The serialized transaction sent out on the network.
    """
    def __init__(
        self,
        *,
        raw_tx: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["raw_tx", b"raw_tx"]) -> None: ...

global___SendOutputsResponse = SendOutputsResponse

@typing.final
class EstimateFeeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONF_TARGET_FIELD_NUMBER: builtins.int
    conf_target: builtins.int
    """
    The number of confirmations to shoot for when estimating the fee.
    """
    def __init__(
        self,
        *,
        conf_target: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["conf_target", b"conf_target"]) -> None: ...

global___EstimateFeeRequest = EstimateFeeRequest

@typing.final
class EstimateFeeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAT_PER_KW_FIELD_NUMBER: builtins.int
    MIN_RELAY_FEE_SAT_PER_KW_FIELD_NUMBER: builtins.int
    sat_per_kw: builtins.int
    """
    The amount of satoshis per kw that should be used in order to reach the
    confirmation target in the request.
    """
    min_relay_fee_sat_per_kw: builtins.int
    """The current minimum relay fee based on our chain backend in sat/kw."""
    def __init__(
        self,
        *,
        sat_per_kw: builtins.int = ...,
        min_relay_fee_sat_per_kw: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["min_relay_fee_sat_per_kw", b"min_relay_fee_sat_per_kw", "sat_per_kw", b"sat_per_kw"]) -> None: ...

global___EstimateFeeResponse = EstimateFeeResponse

@typing.final
class PendingSweep(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUTPOINT_FIELD_NUMBER: builtins.int
    WITNESS_TYPE_FIELD_NUMBER: builtins.int
    AMOUNT_SAT_FIELD_NUMBER: builtins.int
    SAT_PER_BYTE_FIELD_NUMBER: builtins.int
    BROADCAST_ATTEMPTS_FIELD_NUMBER: builtins.int
    NEXT_BROADCAST_HEIGHT_FIELD_NUMBER: builtins.int
    FORCE_FIELD_NUMBER: builtins.int
    REQUESTED_CONF_TARGET_FIELD_NUMBER: builtins.int
    REQUESTED_SAT_PER_BYTE_FIELD_NUMBER: builtins.int
    SAT_PER_VBYTE_FIELD_NUMBER: builtins.int
    REQUESTED_SAT_PER_VBYTE_FIELD_NUMBER: builtins.int
    IMMEDIATE_FIELD_NUMBER: builtins.int
    BUDGET_FIELD_NUMBER: builtins.int
    DEADLINE_HEIGHT_FIELD_NUMBER: builtins.int
    witness_type: global___WitnessType.ValueType
    """The witness type of the output we're attempting to sweep."""
    amount_sat: builtins.int
    """The value of the output we're attempting to sweep."""
    sat_per_byte: builtins.int
    """
    Deprecated, use sat_per_vbyte.
    The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee
    rate is only determined once a sweeping transaction for the output is
    created, so it's possible for this to be 0 before this.
    """
    broadcast_attempts: builtins.int
    """The number of broadcast attempts we've made to sweep the output."""
    next_broadcast_height: builtins.int
    """
    Deprecated.
    The next height of the chain at which we'll attempt to broadcast the
    sweep transaction of the output.
    """
    force: builtins.bool
    """
    Deprecated, use immediate.
    Whether this input must be force-swept. This means that it is swept
    immediately.
    """
    requested_conf_target: builtins.int
    """
    Deprecated, use deadline.
    The requested confirmation target for this output, which is the deadline
    used by the sweeper.
    """
    requested_sat_per_byte: builtins.int
    """Deprecated, use requested_sat_per_vbyte.
    The requested fee rate, expressed in sat/vbyte, for this output.
    """
    sat_per_vbyte: builtins.int
    """
    The current fee rate we'll use to sweep the output, expressed in sat/vbyte.
    The fee rate is only determined once a sweeping transaction for the output
    is created, so it's possible for this to be 0 before this.
    """
    requested_sat_per_vbyte: builtins.int
    """The requested starting fee rate, expressed in sat/vbyte, for this
    output. When not requested, this field will be 0.
    """
    immediate: builtins.bool
    """
    Whether this input will be swept immediately.
    """
    budget: builtins.int
    """
    The budget for this sweep, expressed in satoshis. This is the maximum amount
    that can be spent as fees to sweep this output.
    """
    deadline_height: builtins.int
    """
    The deadline height used for this output when perform fee bumping.
    """
    @property
    def outpoint(self) -> lightning_pb2.OutPoint:
        """The outpoint of the output we're attempting to sweep."""

    def __init__(
        self,
        *,
        outpoint: lightning_pb2.OutPoint | None = ...,
        witness_type: global___WitnessType.ValueType = ...,
        amount_sat: builtins.int = ...,
        sat_per_byte: builtins.int = ...,
        broadcast_attempts: builtins.int = ...,
        next_broadcast_height: builtins.int = ...,
        force: builtins.bool = ...,
        requested_conf_target: builtins.int = ...,
        requested_sat_per_byte: builtins.int = ...,
        sat_per_vbyte: builtins.int = ...,
        requested_sat_per_vbyte: builtins.int = ...,
        immediate: builtins.bool = ...,
        budget: builtins.int = ...,
        deadline_height: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["outpoint", b"outpoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["amount_sat", b"amount_sat", "broadcast_attempts", b"broadcast_attempts", "budget", b"budget", "deadline_height", b"deadline_height", "force", b"force", "immediate", b"immediate", "next_broadcast_height", b"next_broadcast_height", "outpoint", b"outpoint", "requested_conf_target", b"requested_conf_target", "requested_sat_per_byte", b"requested_sat_per_byte", "requested_sat_per_vbyte", b"requested_sat_per_vbyte", "sat_per_byte", b"sat_per_byte", "sat_per_vbyte", b"sat_per_vbyte", "witness_type", b"witness_type"]) -> None: ...

global___PendingSweep = PendingSweep

@typing.final
class PendingSweepsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___PendingSweepsRequest = PendingSweepsRequest

@typing.final
class PendingSweepsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PENDING_SWEEPS_FIELD_NUMBER: builtins.int
    @property
    def pending_sweeps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PendingSweep]:
        """
        The set of outputs currently being swept by lnd's central batching engine.
        """

    def __init__(
        self,
        *,
        pending_sweeps: collections.abc.Iterable[global___PendingSweep] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pending_sweeps", b"pending_sweeps"]) -> None: ...

global___PendingSweepsResponse = PendingSweepsResponse

@typing.final
class BumpFeeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUTPOINT_FIELD_NUMBER: builtins.int
    TARGET_CONF_FIELD_NUMBER: builtins.int
    SAT_PER_BYTE_FIELD_NUMBER: builtins.int
    FORCE_FIELD_NUMBER: builtins.int
    SAT_PER_VBYTE_FIELD_NUMBER: builtins.int
    IMMEDIATE_FIELD_NUMBER: builtins.int
    BUDGET_FIELD_NUMBER: builtins.int
    DEADLINE_DELTA_FIELD_NUMBER: builtins.int
    target_conf: builtins.int
    """Optional. The conf target the underlying fee estimator will use to
    estimate the starting fee rate for the fee function.
    """
    sat_per_byte: builtins.int
    """
    Deprecated, use sat_per_vbyte.
    The fee rate, expressed in sat/vbyte, that should be used to spend the input
    with.
    """
    force: builtins.bool
    """
    Deprecated, use immediate.
    Whether this input must be force-swept. This means that it is swept
    immediately.
    """
    sat_per_vbyte: builtins.int
    """
    Optional. The starting fee rate, expressed in sat/vbyte, that will be used
    to spend the input with initially. This value will be used by the sweeper's
    fee function as its starting fee rate. When not set, the sweeper will use
    the estimated fee rate using the `target_conf` as the starting fee rate.
    """
    immediate: builtins.bool
    """
    Optional. Whether this input will be swept immediately. When set to true,
    the sweeper will sweep this input without waiting for the next batch.
    """
    budget: builtins.int
    """
    Optional. The max amount in sats that can be used as the fees. Setting this
    value greater than the input's value may result in CPFP - one or more wallet
    utxos will be used to pay the fees specified by the budget. If not set, for
    new inputs, by default 50% of the input's value will be treated as the
    budget for fee bumping; for existing inputs, their current budgets will be
    retained.
    """
    deadline_delta: builtins.int
    """Optional. The deadline delta in number of blocks that the output
    should be spent within. This translates internally to the width of the
    fee function that the sweeper will use to bump the fee rate. When the
    deadline is reached, ALL the budget will be spent as fees.
    """
    @property
    def outpoint(self) -> lightning_pb2.OutPoint:
        """The input we're attempting to bump the fee of."""

    def __init__(
        self,
        *,
        outpoint: lightning_pb2.OutPoint | None = ...,
        target_conf: builtins.int = ...,
        sat_per_byte: builtins.int = ...,
        force: builtins.bool = ...,
        sat_per_vbyte: builtins.int = ...,
        immediate: builtins.bool = ...,
        budget: builtins.int = ...,
        deadline_delta: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["outpoint", b"outpoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["budget", b"budget", "deadline_delta", b"deadline_delta", "force", b"force", "immediate", b"immediate", "outpoint", b"outpoint", "sat_per_byte", b"sat_per_byte", "sat_per_vbyte", b"sat_per_vbyte", "target_conf", b"target_conf"]) -> None: ...

global___BumpFeeRequest = BumpFeeRequest

@typing.final
class BumpFeeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATUS_FIELD_NUMBER: builtins.int
    status: builtins.str
    """The status of the bump fee operation."""
    def __init__(
        self,
        *,
        status: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["status", b"status"]) -> None: ...

global___BumpFeeResponse = BumpFeeResponse

@typing.final
class ListSweepsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERBOSE_FIELD_NUMBER: builtins.int
    START_HEIGHT_FIELD_NUMBER: builtins.int
    verbose: builtins.bool
    """
    Retrieve the full sweep transaction details. If false, only the sweep txids
    will be returned. Note that some sweeps that LND publishes will have been
    replaced-by-fee, so will not be included in this output.
    """
    start_height: builtins.int
    """
    The start height to use when fetching sweeps. If not specified (0), the
    result will start from the earliest sweep. If set to -1 the result will
    only include unconfirmed sweeps (at the time of the call).
    """
    def __init__(
        self,
        *,
        verbose: builtins.bool = ...,
        start_height: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["start_height", b"start_height", "verbose", b"verbose"]) -> None: ...

global___ListSweepsRequest = ListSweepsRequest

@typing.final
class ListSweepsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class TransactionIDs(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TRANSACTION_IDS_FIELD_NUMBER: builtins.int
        @property
        def transaction_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """
            Reversed, hex-encoded string representing the transaction ids of the
            sweeps that our node has broadcast. Note that these transactions may
            not have confirmed yet, we record sweeps on broadcast, not confirmation.
            """

        def __init__(
            self,
            *,
            transaction_ids: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["transaction_ids", b"transaction_ids"]) -> None: ...

    TRANSACTION_DETAILS_FIELD_NUMBER: builtins.int
    TRANSACTION_IDS_FIELD_NUMBER: builtins.int
    @property
    def transaction_details(self) -> lightning_pb2.TransactionDetails: ...
    @property
    def transaction_ids(self) -> global___ListSweepsResponse.TransactionIDs: ...
    def __init__(
        self,
        *,
        transaction_details: lightning_pb2.TransactionDetails | None = ...,
        transaction_ids: global___ListSweepsResponse.TransactionIDs | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["sweeps", b"sweeps", "transaction_details", b"transaction_details", "transaction_ids", b"transaction_ids"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["sweeps", b"sweeps", "transaction_details", b"transaction_details", "transaction_ids", b"transaction_ids"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["sweeps", b"sweeps"]) -> typing.Literal["transaction_details", "transaction_ids"] | None: ...

global___ListSweepsResponse = ListSweepsResponse

@typing.final
class LabelTransactionRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TXID_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    OVERWRITE_FIELD_NUMBER: builtins.int
    txid: builtins.bytes
    """The txid of the transaction to label. Note: When using gRPC, the bytes
    must be in little-endian (reverse) order.
    """
    label: builtins.str
    """The label to add to the transaction, limited to 500 characters."""
    overwrite: builtins.bool
    """Whether to overwrite the existing label, if it is present."""
    def __init__(
        self,
        *,
        txid: builtins.bytes = ...,
        label: builtins.str = ...,
        overwrite: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["label", b"label", "overwrite", b"overwrite", "txid", b"txid"]) -> None: ...

global___LabelTransactionRequest = LabelTransactionRequest

@typing.final
class LabelTransactionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___LabelTransactionResponse = LabelTransactionResponse

@typing.final
class FundPsbtRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PSBT_FIELD_NUMBER: builtins.int
    RAW_FIELD_NUMBER: builtins.int
    COIN_SELECT_FIELD_NUMBER: builtins.int
    TARGET_CONF_FIELD_NUMBER: builtins.int
    SAT_PER_VBYTE_FIELD_NUMBER: builtins.int
    ACCOUNT_FIELD_NUMBER: builtins.int
    MIN_CONFS_FIELD_NUMBER: builtins.int
    SPEND_UNCONFIRMED_FIELD_NUMBER: builtins.int
    CHANGE_TYPE_FIELD_NUMBER: builtins.int
    COIN_SELECTION_STRATEGY_FIELD_NUMBER: builtins.int
    psbt: builtins.bytes
    """
    Use an existing PSBT packet as the template for the funded PSBT.

    The packet must contain at least one non-dust output. If one or more
    inputs are specified, no coin selection is performed. In that case every
    input must be an UTXO known to the wallet that has not been locked
    before. The sum of all inputs must be sufficiently greater than the sum
    of all outputs to pay a miner fee with the specified fee rate. A change
    output is added to the PSBT if necessary.
    """
    target_conf: builtins.int
    """
    The target number of blocks that the transaction should be confirmed in.
    """
    sat_per_vbyte: builtins.int
    """
    The fee rate, expressed in sat/vbyte, that should be used to spend the
    input with.
    """
    account: builtins.str
    """
    The name of the account to fund the PSBT with. If empty, the default wallet
    account is used.
    """
    min_confs: builtins.int
    """The minimum number of confirmations each one of your outputs used for
    the transaction must satisfy.
    """
    spend_unconfirmed: builtins.bool
    """Whether unconfirmed outputs should be used as inputs for the transaction."""
    change_type: global___ChangeAddressType.ValueType
    """The address type for the change. If empty, P2WPKH addresses will be used
    for default accounts and single imported public keys. For custom
    accounts, no change type should be provided as the coin selection key
    scope will always be used to generate the change address.
    """
    coin_selection_strategy: lightning_pb2.CoinSelectionStrategy.ValueType
    """The strategy to use for selecting coins during funding the PSBT."""
    @property
    def raw(self) -> global___TxTemplate:
        """
        Use the outputs and optional inputs from this raw template.
        """

    @property
    def coin_select(self) -> global___PsbtCoinSelect:
        """
        Use an existing PSBT packet as the template for the funded PSBT.

        The difference to the pure PSBT template above is that coin selection is
        performed even if inputs are specified. The output amounts are summed up
        and used as the target amount for coin selection. A change output must
        either already exist in the PSBT and be marked as such, otherwise a new
        change output of the specified output type will be added. Any inputs
        already specified in the PSBT must already be locked (if they belong to
        this node), only newly added inputs will be locked by this RPC.

        In case the sum of the already provided inputs exceeds the required
        output amount, no new coins are selected. Instead only the fee and
        change amount calculation is performed (e.g. a change output is added if
        requested or the change is added to the specified existing change
        output, given there is any non-dust change). This can be identified by
        the returned locked UTXOs being empty.
        """

    def __init__(
        self,
        *,
        psbt: builtins.bytes = ...,
        raw: global___TxTemplate | None = ...,
        coin_select: global___PsbtCoinSelect | None = ...,
        target_conf: builtins.int = ...,
        sat_per_vbyte: builtins.int = ...,
        account: builtins.str = ...,
        min_confs: builtins.int = ...,
        spend_unconfirmed: builtins.bool = ...,
        change_type: global___ChangeAddressType.ValueType = ...,
        coin_selection_strategy: lightning_pb2.CoinSelectionStrategy.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["coin_select", b"coin_select", "fees", b"fees", "psbt", b"psbt", "raw", b"raw", "sat_per_vbyte", b"sat_per_vbyte", "target_conf", b"target_conf", "template", b"template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["account", b"account", "change_type", b"change_type", "coin_select", b"coin_select", "coin_selection_strategy", b"coin_selection_strategy", "fees", b"fees", "min_confs", b"min_confs", "psbt", b"psbt", "raw", b"raw", "sat_per_vbyte", b"sat_per_vbyte", "spend_unconfirmed", b"spend_unconfirmed", "target_conf", b"target_conf", "template", b"template"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["fees", b"fees"]) -> typing.Literal["target_conf", "sat_per_vbyte"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["template", b"template"]) -> typing.Literal["psbt", "raw", "coin_select"] | None: ...

global___FundPsbtRequest = FundPsbtRequest

@typing.final
class FundPsbtResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNDED_PSBT_FIELD_NUMBER: builtins.int
    CHANGE_OUTPUT_INDEX_FIELD_NUMBER: builtins.int
    LOCKED_UTXOS_FIELD_NUMBER: builtins.int
    funded_psbt: builtins.bytes
    """
    The funded but not yet signed PSBT packet.
    """
    change_output_index: builtins.int
    """
    The index of the added change output or -1 if no change was left over.
    """
    @property
    def locked_utxos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UtxoLease]:
        """
        The list of lock leases that were acquired for the inputs in the funded PSBT
        packet. Only inputs added to the PSBT by this RPC are locked, inputs that
        were already present in the PSBT are not locked.
        """

    def __init__(
        self,
        *,
        funded_psbt: builtins.bytes = ...,
        change_output_index: builtins.int = ...,
        locked_utxos: collections.abc.Iterable[global___UtxoLease] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["change_output_index", b"change_output_index", "funded_psbt", b"funded_psbt", "locked_utxos", b"locked_utxos"]) -> None: ...

global___FundPsbtResponse = FundPsbtResponse

@typing.final
class TxTemplate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class OutputsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.int
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    INPUTS_FIELD_NUMBER: builtins.int
    OUTPUTS_FIELD_NUMBER: builtins.int
    @property
    def inputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[lightning_pb2.OutPoint]:
        """
        An optional list of inputs to use. Every input must be an UTXO known to the
        wallet that has not been locked before. The sum of all inputs must be
        sufficiently greater than the sum of all outputs to pay a miner fee with the
        fee rate specified in the parent message.

        If no inputs are specified, coin selection will be performed instead and
        inputs of sufficient value will be added to the resulting PSBT.
        """

    @property
    def outputs(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.int]:
        """
        A map of all addresses and the amounts to send to in the funded PSBT.
        """

    def __init__(
        self,
        *,
        inputs: collections.abc.Iterable[lightning_pb2.OutPoint] | None = ...,
        outputs: collections.abc.Mapping[builtins.str, builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["inputs", b"inputs", "outputs", b"outputs"]) -> None: ...

global___TxTemplate = TxTemplate

@typing.final
class PsbtCoinSelect(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PSBT_FIELD_NUMBER: builtins.int
    EXISTING_OUTPUT_INDEX_FIELD_NUMBER: builtins.int
    ADD_FIELD_NUMBER: builtins.int
    psbt: builtins.bytes
    """
    The template to use for the funded PSBT. The template must contain at least
    one non-dust output. The amount to be funded is calculated by summing up the
    amounts of all outputs in the template, subtracting all the input values of
    the already specified inputs. The change value is added to the output that
    is marked as such (or a new change output is added if none is marked). For
    the input amount calculation to be correct, the template must have the
    WitnessUtxo field set for all inputs. Any inputs already specified in the
    PSBT must already be locked (if they belong to this node), only newly added
    inputs will be locked by this RPC.
    """
    existing_output_index: builtins.int
    """
    Use the existing output within the template PSBT with the specified
    index as the change output. Any leftover change will be added to the
    already specified amount of that output. To add a new change output to
    the PSBT, set the "add" field below instead. The type of change output
    added is defined by change_type in the parent message.
    """
    add: builtins.bool
    """
    Add a new change output to the PSBT using the change_type specified in
    the parent message.
    """
    def __init__(
        self,
        *,
        psbt: builtins.bytes = ...,
        existing_output_index: builtins.int = ...,
        add: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["add", b"add", "change_output", b"change_output", "existing_output_index", b"existing_output_index"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["add", b"add", "change_output", b"change_output", "existing_output_index", b"existing_output_index", "psbt", b"psbt"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["change_output", b"change_output"]) -> typing.Literal["existing_output_index", "add"] | None: ...

global___PsbtCoinSelect = PsbtCoinSelect

@typing.final
class UtxoLease(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    OUTPOINT_FIELD_NUMBER: builtins.int
    EXPIRATION_FIELD_NUMBER: builtins.int
    PK_SCRIPT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    id: builtins.bytes
    """
    A 32 byte random ID that identifies the lease.
    """
    expiration: builtins.int
    """
    The absolute expiration of the output lease represented as a unix timestamp.
    """
    pk_script: builtins.bytes
    """
    The public key script of the leased output.
    """
    value: builtins.int
    """
    The value of the leased output in satoshis.
    """
    @property
    def outpoint(self) -> lightning_pb2.OutPoint:
        """The identifying outpoint of the output being leased."""

    def __init__(
        self,
        *,
        id: builtins.bytes = ...,
        outpoint: lightning_pb2.OutPoint | None = ...,
        expiration: builtins.int = ...,
        pk_script: builtins.bytes = ...,
        value: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["outpoint", b"outpoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["expiration", b"expiration", "id", b"id", "outpoint", b"outpoint", "pk_script", b"pk_script", "value", b"value"]) -> None: ...

global___UtxoLease = UtxoLease

@typing.final
class SignPsbtRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNDED_PSBT_FIELD_NUMBER: builtins.int
    funded_psbt: builtins.bytes
    """
    The PSBT that should be signed. The PSBT must contain all required inputs,
    outputs, UTXO data and custom fields required to identify the signing key.
    """
    def __init__(
        self,
        *,
        funded_psbt: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["funded_psbt", b"funded_psbt"]) -> None: ...

global___SignPsbtRequest = SignPsbtRequest

@typing.final
class SignPsbtResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIGNED_PSBT_FIELD_NUMBER: builtins.int
    SIGNED_INPUTS_FIELD_NUMBER: builtins.int
    signed_psbt: builtins.bytes
    """The signed transaction in PSBT format."""
    @property
    def signed_inputs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The indices of signed inputs."""

    def __init__(
        self,
        *,
        signed_psbt: builtins.bytes = ...,
        signed_inputs: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["signed_inputs", b"signed_inputs", "signed_psbt", b"signed_psbt"]) -> None: ...

global___SignPsbtResponse = SignPsbtResponse

@typing.final
class FinalizePsbtRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNDED_PSBT_FIELD_NUMBER: builtins.int
    ACCOUNT_FIELD_NUMBER: builtins.int
    funded_psbt: builtins.bytes
    """
    A PSBT that should be signed and finalized. The PSBT must contain all
    required inputs, outputs, UTXO data and partial signatures of all other
    signers.
    """
    account: builtins.str
    """
    The name of the account to finalize the PSBT with. If empty, the default
    wallet account is used.
    """
    def __init__(
        self,
        *,
        funded_psbt: builtins.bytes = ...,
        account: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["account", b"account", "funded_psbt", b"funded_psbt"]) -> None: ...

global___FinalizePsbtRequest = FinalizePsbtRequest

@typing.final
class FinalizePsbtResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIGNED_PSBT_FIELD_NUMBER: builtins.int
    RAW_FINAL_TX_FIELD_NUMBER: builtins.int
    signed_psbt: builtins.bytes
    """The fully signed and finalized transaction in PSBT format."""
    raw_final_tx: builtins.bytes
    """The fully signed and finalized transaction in the raw wire format."""
    def __init__(
        self,
        *,
        signed_psbt: builtins.bytes = ...,
        raw_final_tx: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["raw_final_tx", b"raw_final_tx", "signed_psbt", b"signed_psbt"]) -> None: ...

global___FinalizePsbtResponse = FinalizePsbtResponse

@typing.final
class ListLeasesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___ListLeasesRequest = ListLeasesRequest

@typing.final
class ListLeasesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCKED_UTXOS_FIELD_NUMBER: builtins.int
    @property
    def locked_utxos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UtxoLease]:
        """The list of currently leased utxos."""

    def __init__(
        self,
        *,
        locked_utxos: collections.abc.Iterable[global___UtxoLease] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["locked_utxos", b"locked_utxos"]) -> None: ...

global___ListLeasesResponse = ListLeasesResponse
