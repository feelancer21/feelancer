"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SignMethod:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SignMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SignMethod.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SIGN_METHOD_WITNESS_V0: _SignMethod.ValueType  # 0
    """
    Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
    signed.
    """
    SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086: _SignMethod.ValueType  # 1
    """
    Specifies that a SegWit v1 (p2tr) input should be signed by using the
    BIP0086 method (commit to internal key only).
    """
    SIGN_METHOD_TAPROOT_KEY_SPEND: _SignMethod.ValueType  # 2
    """
    Specifies that a SegWit v1 (p2tr) input should be signed by using a given
    taproot hash to commit to in addition to the internal key.
    """
    SIGN_METHOD_TAPROOT_SCRIPT_SPEND: _SignMethod.ValueType  # 3
    """
    Specifies that a SegWit v1 (p2tr) input should be spent using the script
    path and that a specific leaf script should be signed for.
    """

class SignMethod(_SignMethod, metaclass=_SignMethodEnumTypeWrapper): ...

SIGN_METHOD_WITNESS_V0: SignMethod.ValueType  # 0
"""
Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
signed.
"""
SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086: SignMethod.ValueType  # 1
"""
Specifies that a SegWit v1 (p2tr) input should be signed by using the
BIP0086 method (commit to internal key only).
"""
SIGN_METHOD_TAPROOT_KEY_SPEND: SignMethod.ValueType  # 2
"""
Specifies that a SegWit v1 (p2tr) input should be signed by using a given
taproot hash to commit to in addition to the internal key.
"""
SIGN_METHOD_TAPROOT_SCRIPT_SPEND: SignMethod.ValueType  # 3
"""
Specifies that a SegWit v1 (p2tr) input should be spent using the script
path and that a specific leaf script should be signed for.
"""
global___SignMethod = SignMethod

class _MuSig2Version:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MuSig2VersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MuSig2Version.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    MUSIG2_VERSION_UNDEFINED: _MuSig2Version.ValueType  # 0
    """
    The default value on the RPC is zero for enums so we need to represent an
    invalid/undefined version by default to make sure clients upgrade their
    software to set the version explicitly.
    """
    MUSIG2_VERSION_V040: _MuSig2Version.ValueType  # 1
    """
    The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the
    version v0.4.0 of the MuSig2 BIP draft.
    """
    MUSIG2_VERSION_V100RC2: _MuSig2Version.ValueType  # 2
    """
    The current version of MuSig2 which corresponds to the version v1.0.0rc2 of
    the MuSig2 BIP draft.
    """

class MuSig2Version(_MuSig2Version, metaclass=_MuSig2VersionEnumTypeWrapper): ...

MUSIG2_VERSION_UNDEFINED: MuSig2Version.ValueType  # 0
"""
The default value on the RPC is zero for enums so we need to represent an
invalid/undefined version by default to make sure clients upgrade their
software to set the version explicitly.
"""
MUSIG2_VERSION_V040: MuSig2Version.ValueType  # 1
"""
The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the
version v0.4.0 of the MuSig2 BIP draft.
"""
MUSIG2_VERSION_V100RC2: MuSig2Version.ValueType  # 2
"""
The current version of MuSig2 which corresponds to the version v1.0.0rc2 of
the MuSig2 BIP draft.
"""
global___MuSig2Version = MuSig2Version

@typing.final
class KeyLocator(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FAMILY_FIELD_NUMBER: builtins.int
    KEY_INDEX_FIELD_NUMBER: builtins.int
    key_family: builtins.int
    """The family of key being identified."""
    key_index: builtins.int
    """The precise index of the key being identified."""
    def __init__(
        self,
        *,
        key_family: builtins.int = ...,
        key_index: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key_family", b"key_family", "key_index", b"key_index"]) -> None: ...

global___KeyLocator = KeyLocator

@typing.final
class KeyDescriptor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAW_KEY_BYTES_FIELD_NUMBER: builtins.int
    KEY_LOC_FIELD_NUMBER: builtins.int
    raw_key_bytes: builtins.bytes
    """
    The raw bytes of the public key in the key pair being identified. Either
    this or the KeyLocator must be specified.
    """
    @property
    def key_loc(self) -> global___KeyLocator:
        """
        The key locator that identifies which private key to use for signing.
        Either this or the raw bytes of the target public key must be specified.
        """

    def __init__(
        self,
        *,
        raw_key_bytes: builtins.bytes = ...,
        key_loc: global___KeyLocator | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_loc", b"key_loc"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key_loc", b"key_loc", "raw_key_bytes", b"raw_key_bytes"]) -> None: ...

global___KeyDescriptor = KeyDescriptor

@typing.final
class TxOut(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    PK_SCRIPT_FIELD_NUMBER: builtins.int
    value: builtins.int
    """The value of the output being spent."""
    pk_script: builtins.bytes
    """The script of the output being spent."""
    def __init__(
        self,
        *,
        value: builtins.int = ...,
        pk_script: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pk_script", b"pk_script", "value", b"value"]) -> None: ...

global___TxOut = TxOut

@typing.final
class SignDescriptor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_DESC_FIELD_NUMBER: builtins.int
    SINGLE_TWEAK_FIELD_NUMBER: builtins.int
    DOUBLE_TWEAK_FIELD_NUMBER: builtins.int
    TAP_TWEAK_FIELD_NUMBER: builtins.int
    WITNESS_SCRIPT_FIELD_NUMBER: builtins.int
    OUTPUT_FIELD_NUMBER: builtins.int
    SIGHASH_FIELD_NUMBER: builtins.int
    INPUT_INDEX_FIELD_NUMBER: builtins.int
    SIGN_METHOD_FIELD_NUMBER: builtins.int
    single_tweak: builtins.bytes
    """
    A scalar value that will be added to the private key corresponding to the
    above public key to obtain the private key to be used to sign this input.
    This value is typically derived via the following computation:

    derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
    """
    double_tweak: builtins.bytes
    """
    A private key that will be used in combination with its corresponding
    private key to derive the private key that is to be used to sign the target
    input. Within the Lightning protocol, this value is typically the
    commitment secret from a previously revoked commitment transaction. This
    value is in combination with two hash values, and the original private key
    to derive the private key to be used when signing.

    k = (privKey*sha256(pubKey || tweakPub) +
    tweakPriv*sha256(tweakPub || pubKey)) mod N
    """
    tap_tweak: builtins.bytes
    """
    The 32 byte input to the taproot tweak derivation that is used to derive
    the output key from an internal key: outputKey = internalKey +
    tagged_hash("tapTweak", internalKey || tapTweak).

    When doing a BIP 86 spend, this field can be an empty byte slice.

    When doing a normal key path spend, with the output key committing to an
    actual script root, then this field should be: the tapscript root hash.
    """
    witness_script: builtins.bytes
    """
    The full script required to properly redeem the output. This field will
    only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
    taproot script path spend is being attempted, then this should be the raw
    leaf script.
    """
    sighash: builtins.int
    """
    The target sighash type that should be used when generating the final
    sighash, and signature.
    """
    input_index: builtins.int
    """
    The target input within the transaction that should be signed.
    """
    sign_method: global___SignMethod.ValueType
    """
    The sign method specifies how the input should be signed. Depending on the
    method, either the tap_tweak, witness_script or both need to be specified.
    Defaults to SegWit v0 signing to be backward compatible with older RPC
    clients.
    """
    @property
    def key_desc(self) -> global___KeyDescriptor:
        """
        A descriptor that precisely describes *which* key to use for signing. This
        may provide the raw public key directly, or require the Signer to re-derive
        the key according to the populated derivation path.

        Note that if the key descriptor was obtained through walletrpc.DeriveKey,
        then the key locator MUST always be provided, since the derived keys are not
        persisted unlike with DeriveNextKey.
        """

    @property
    def output(self) -> global___TxOut:
        """
        A description of the output being spent. The value and script MUST be
        provided.
        """

    def __init__(
        self,
        *,
        key_desc: global___KeyDescriptor | None = ...,
        single_tweak: builtins.bytes = ...,
        double_tweak: builtins.bytes = ...,
        tap_tweak: builtins.bytes = ...,
        witness_script: builtins.bytes = ...,
        output: global___TxOut | None = ...,
        sighash: builtins.int = ...,
        input_index: builtins.int = ...,
        sign_method: global___SignMethod.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_desc", b"key_desc", "output", b"output"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["double_tweak", b"double_tweak", "input_index", b"input_index", "key_desc", b"key_desc", "output", b"output", "sighash", b"sighash", "sign_method", b"sign_method", "single_tweak", b"single_tweak", "tap_tweak", b"tap_tweak", "witness_script", b"witness_script"]) -> None: ...

global___SignDescriptor = SignDescriptor

@typing.final
class SignReq(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAW_TX_BYTES_FIELD_NUMBER: builtins.int
    SIGN_DESCS_FIELD_NUMBER: builtins.int
    PREV_OUTPUTS_FIELD_NUMBER: builtins.int
    raw_tx_bytes: builtins.bytes
    """The raw bytes of the transaction to be signed."""
    @property
    def sign_descs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SignDescriptor]:
        """A set of sign descriptors, for each input to be signed."""

    @property
    def prev_outputs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TxOut]:
        """
        The full list of UTXO information for each of the inputs being spent. This
        is required when spending one or more taproot (SegWit v1) outputs.
        """

    def __init__(
        self,
        *,
        raw_tx_bytes: builtins.bytes = ...,
        sign_descs: collections.abc.Iterable[global___SignDescriptor] | None = ...,
        prev_outputs: collections.abc.Iterable[global___TxOut] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["prev_outputs", b"prev_outputs", "raw_tx_bytes", b"raw_tx_bytes", "sign_descs", b"sign_descs"]) -> None: ...

global___SignReq = SignReq

@typing.final
class SignResp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAW_SIGS_FIELD_NUMBER: builtins.int
    @property
    def raw_sigs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        A set of signatures realized in a fixed 64-byte format ordered in ascending
        input order.
        """

    def __init__(
        self,
        *,
        raw_sigs: collections.abc.Iterable[builtins.bytes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["raw_sigs", b"raw_sigs"]) -> None: ...

global___SignResp = SignResp

@typing.final
class InputScript(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WITNESS_FIELD_NUMBER: builtins.int
    SIG_SCRIPT_FIELD_NUMBER: builtins.int
    sig_script: builtins.bytes
    """
    The optional sig script for the specified witness that will only be set if
    the input specified is a nested p2sh witness program.
    """
    @property
    def witness(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """The serializes witness stack for the specified input."""

    def __init__(
        self,
        *,
        witness: collections.abc.Iterable[builtins.bytes] | None = ...,
        sig_script: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sig_script", b"sig_script", "witness", b"witness"]) -> None: ...

global___InputScript = InputScript

@typing.final
class InputScriptResp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INPUT_SCRIPTS_FIELD_NUMBER: builtins.int
    @property
    def input_scripts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputScript]:
        """The set of fully valid input scripts requested."""

    def __init__(
        self,
        *,
        input_scripts: collections.abc.Iterable[global___InputScript] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["input_scripts", b"input_scripts"]) -> None: ...

global___InputScriptResp = InputScriptResp

@typing.final
class SignMessageReq(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MSG_FIELD_NUMBER: builtins.int
    KEY_LOC_FIELD_NUMBER: builtins.int
    DOUBLE_HASH_FIELD_NUMBER: builtins.int
    COMPACT_SIG_FIELD_NUMBER: builtins.int
    SCHNORR_SIG_FIELD_NUMBER: builtins.int
    SCHNORR_SIG_TAP_TWEAK_FIELD_NUMBER: builtins.int
    TAG_FIELD_NUMBER: builtins.int
    msg: builtins.bytes
    """
    The message to be signed. When using REST, this field must be encoded as
    base64.
    """
    double_hash: builtins.bool
    """Double-SHA256 hash instead of just the default single round."""
    compact_sig: builtins.bool
    """
    Use the compact (pubkey recoverable) format instead of the raw lnwire
    format. This option cannot be used with Schnorr signatures.
    """
    schnorr_sig: builtins.bool
    """
    Use Schnorr signature. This option cannot be used with compact format.
    """
    schnorr_sig_tap_tweak: builtins.bytes
    """
    The optional Taproot tweak bytes to apply to the private key before creating
    a Schnorr signature. The private key is tweaked as described in BIP-341:
    privKey + h_tapTweak(internalKey || tapTweak)
    """
    tag: builtins.bytes
    """
    An optional tag that can be provided when taking a tagged hash of a
    message. This option can only be used when schnorr_sig is true.
    """
    @property
    def key_loc(self) -> global___KeyLocator:
        """The key locator that identifies which key to use for signing."""

    def __init__(
        self,
        *,
        msg: builtins.bytes = ...,
        key_loc: global___KeyLocator | None = ...,
        double_hash: builtins.bool = ...,
        compact_sig: builtins.bool = ...,
        schnorr_sig: builtins.bool = ...,
        schnorr_sig_tap_tweak: builtins.bytes = ...,
        tag: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_loc", b"key_loc"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["compact_sig", b"compact_sig", "double_hash", b"double_hash", "key_loc", b"key_loc", "msg", b"msg", "schnorr_sig", b"schnorr_sig", "schnorr_sig_tap_tweak", b"schnorr_sig_tap_tweak", "tag", b"tag"]) -> None: ...

global___SignMessageReq = SignMessageReq

@typing.final
class SignMessageResp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIGNATURE_FIELD_NUMBER: builtins.int
    signature: builtins.bytes
    """
    The signature for the given message in the fixed-size LN wire format.
    """
    def __init__(
        self,
        *,
        signature: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["signature", b"signature"]) -> None: ...

global___SignMessageResp = SignMessageResp

@typing.final
class VerifyMessageReq(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MSG_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    PUBKEY_FIELD_NUMBER: builtins.int
    IS_SCHNORR_SIG_FIELD_NUMBER: builtins.int
    TAG_FIELD_NUMBER: builtins.int
    msg: builtins.bytes
    """The message over which the signature is to be verified. When using
    REST, this field must be encoded as base64.
    """
    signature: builtins.bytes
    """
    The fixed-size LN wire encoded signature to be verified over the given
    message. When using REST, this field must be encoded as base64.
    """
    pubkey: builtins.bytes
    """
    The public key the signature has to be valid for. When using REST, this
    field must be encoded as base64. If the is_schnorr_sig option is true, then
    the public key is expected to be in the 32-byte x-only serialization
    according to BIP-340.
    """
    is_schnorr_sig: builtins.bool
    """
    Specifies if the signature is a Schnorr signature.
    """
    tag: builtins.bytes
    """
    An optional tag that can be provided when taking a tagged hash of a
    message. This option can only be used when is_schnorr_sig is true.
    """
    def __init__(
        self,
        *,
        msg: builtins.bytes = ...,
        signature: builtins.bytes = ...,
        pubkey: builtins.bytes = ...,
        is_schnorr_sig: builtins.bool = ...,
        tag: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["is_schnorr_sig", b"is_schnorr_sig", "msg", b"msg", "pubkey", b"pubkey", "signature", b"signature", "tag", b"tag"]) -> None: ...

global___VerifyMessageReq = VerifyMessageReq

@typing.final
class VerifyMessageResp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALID_FIELD_NUMBER: builtins.int
    valid: builtins.bool
    """Whether the signature was valid over the given message."""
    def __init__(
        self,
        *,
        valid: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["valid", b"valid"]) -> None: ...

global___VerifyMessageResp = VerifyMessageResp

@typing.final
class SharedKeyRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EPHEMERAL_PUBKEY_FIELD_NUMBER: builtins.int
    KEY_LOC_FIELD_NUMBER: builtins.int
    KEY_DESC_FIELD_NUMBER: builtins.int
    ephemeral_pubkey: builtins.bytes
    """The ephemeral public key to use for the DH key derivation."""
    @property
    def key_loc(self) -> global___KeyLocator:
        """
        Deprecated. The optional key locator of the local key that should be used.
        If this parameter is not set then the node's identity private key will be
        used.
        """

    @property
    def key_desc(self) -> global___KeyDescriptor:
        """
        A key descriptor describes the key used for performing ECDH. Either a key
        locator or a raw public key is expected, if neither is supplied, defaults to
        the node's identity private key.
        """

    def __init__(
        self,
        *,
        ephemeral_pubkey: builtins.bytes = ...,
        key_loc: global___KeyLocator | None = ...,
        key_desc: global___KeyDescriptor | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_desc", b"key_desc", "key_loc", b"key_loc"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["ephemeral_pubkey", b"ephemeral_pubkey", "key_desc", b"key_desc", "key_loc", b"key_loc"]) -> None: ...

global___SharedKeyRequest = SharedKeyRequest

@typing.final
class SharedKeyResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARED_KEY_FIELD_NUMBER: builtins.int
    shared_key: builtins.bytes
    """The shared public key, hashed with sha256."""
    def __init__(
        self,
        *,
        shared_key: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["shared_key", b"shared_key"]) -> None: ...

global___SharedKeyResponse = SharedKeyResponse

@typing.final
class TweakDesc(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TWEAK_FIELD_NUMBER: builtins.int
    IS_X_ONLY_FIELD_NUMBER: builtins.int
    tweak: builtins.bytes
    """
    Tweak is the 32-byte value that will modify the public key.
    """
    is_x_only: builtins.bool
    """
    Specifies if the target key should be converted to an x-only public key
    before tweaking. If true, then the public key will be mapped to an x-only
    key before the tweaking operation is applied.
    """
    def __init__(
        self,
        *,
        tweak: builtins.bytes = ...,
        is_x_only: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["is_x_only", b"is_x_only", "tweak", b"tweak"]) -> None: ...

global___TweakDesc = TweakDesc

@typing.final
class TaprootTweakDesc(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCRIPT_ROOT_FIELD_NUMBER: builtins.int
    KEY_SPEND_ONLY_FIELD_NUMBER: builtins.int
    script_root: builtins.bytes
    """
    The root hash of the tapscript tree if a script path is committed to. If
    the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
    key spend only), then this needs to be empty and the key_spend_only field
    below must be set to true. This is required because gRPC cannot
    differentiate between a zero-size byte slice and a nil byte slice (both
    would be serialized the same way). So the extra boolean is required.
    """
    key_spend_only: builtins.bool
    """
    Indicates that the above script_root is expected to be empty because this
    is a BIP-0086 key spend only commitment where only the internal key is
    committed to instead of also including a script root hash.
    """
    def __init__(
        self,
        *,
        script_root: builtins.bytes = ...,
        key_spend_only: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key_spend_only", b"key_spend_only", "script_root", b"script_root"]) -> None: ...

global___TaprootTweakDesc = TaprootTweakDesc

@typing.final
class MuSig2CombineKeysRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALL_SIGNER_PUBKEYS_FIELD_NUMBER: builtins.int
    TWEAKS_FIELD_NUMBER: builtins.int
    TAPROOT_TWEAK_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    version: global___MuSig2Version.ValueType
    """
    The mandatory version of the MuSig2 BIP draft to use. This is necessary to
    differentiate between the changes that were made to the BIP while this
    experimental RPC was already released. Some of those changes affect how the
    combined key and nonces are created.
    """
    @property
    def all_signer_pubkeys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        A list of all public keys (serialized in 32-byte x-only format for v0.4.0
        and 33-byte compressed format for v1.0.0rc2!) participating in the signing
        session. The list will always be sorted lexicographically internally. This
        must include the local key which is described by the above key_loc.
        """

    @property
    def tweaks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TweakDesc]:
        """
        A series of optional generic tweaks to be applied to the aggregated
        public key.
        """

    @property
    def taproot_tweak(self) -> global___TaprootTweakDesc:
        """
        An optional taproot specific tweak that must be specified if the MuSig2
        combined key will be used as the main taproot key of a taproot output
        on-chain.
        """

    def __init__(
        self,
        *,
        all_signer_pubkeys: collections.abc.Iterable[builtins.bytes] | None = ...,
        tweaks: collections.abc.Iterable[global___TweakDesc] | None = ...,
        taproot_tweak: global___TaprootTweakDesc | None = ...,
        version: global___MuSig2Version.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["taproot_tweak", b"taproot_tweak"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["all_signer_pubkeys", b"all_signer_pubkeys", "taproot_tweak", b"taproot_tweak", "tweaks", b"tweaks", "version", b"version"]) -> None: ...

global___MuSig2CombineKeysRequest = MuSig2CombineKeysRequest

@typing.final
class MuSig2CombineKeysResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMBINED_KEY_FIELD_NUMBER: builtins.int
    TAPROOT_INTERNAL_KEY_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    combined_key: builtins.bytes
    """
    The combined public key (in the 32-byte x-only format) with all tweaks
    applied to it. If a taproot tweak is specified, this corresponds to the
    taproot key that can be put into the on-chain output.
    """
    taproot_internal_key: builtins.bytes
    """
    The raw combined public key (in the 32-byte x-only format) before any tweaks
    are applied to it. If a taproot tweak is specified, this corresponds to the
    internal key that needs to be put into the witness if the script spend path
    is used.
    """
    version: global___MuSig2Version.ValueType
    """
    The version of the MuSig2 BIP that was used to combine the keys.
    """
    def __init__(
        self,
        *,
        combined_key: builtins.bytes = ...,
        taproot_internal_key: builtins.bytes = ...,
        version: global___MuSig2Version.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["combined_key", b"combined_key", "taproot_internal_key", b"taproot_internal_key", "version", b"version"]) -> None: ...

global___MuSig2CombineKeysResponse = MuSig2CombineKeysResponse

@typing.final
class MuSig2SessionRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_LOC_FIELD_NUMBER: builtins.int
    ALL_SIGNER_PUBKEYS_FIELD_NUMBER: builtins.int
    OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER: builtins.int
    TWEAKS_FIELD_NUMBER: builtins.int
    TAPROOT_TWEAK_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    PREGENERATED_LOCAL_NONCE_FIELD_NUMBER: builtins.int
    version: global___MuSig2Version.ValueType
    """
    The mandatory version of the MuSig2 BIP draft to use. This is necessary to
    differentiate between the changes that were made to the BIP while this
    experimental RPC was already released. Some of those changes affect how the
    combined key and nonces are created.
    """
    pregenerated_local_nonce: builtins.bytes
    """
    A set of pre generated secret local nonces to use in the musig2 session.
    This field is optional. This can be useful for protocols that need to send
    nonces ahead of time before the set of signer keys are known. This value
    MUST be 97 bytes and be the concatenation of two CSPRNG generated 32 byte
    values and local public key used for signing as specified in the key_loc
    field.
    """
    @property
    def key_loc(self) -> global___KeyLocator:
        """
        The key locator that identifies which key to use for signing.
        """

    @property
    def all_signer_pubkeys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        A list of all public keys (serialized in 32-byte x-only format for v0.4.0
        and 33-byte compressed format for v1.0.0rc2!) participating in the signing
        session. The list will always be sorted lexicographically internally. This
        must include the local key which is described by the above key_loc.
        """

    @property
    def other_signer_public_nonces(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        An optional list of all public nonces of other signing participants that
        might already be known.
        """

    @property
    def tweaks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TweakDesc]:
        """
        A series of optional generic tweaks to be applied to the aggregated
        public key.
        """

    @property
    def taproot_tweak(self) -> global___TaprootTweakDesc:
        """
        An optional taproot specific tweak that must be specified if the MuSig2
        combined key will be used as the main taproot key of a taproot output
        on-chain.
        """

    def __init__(
        self,
        *,
        key_loc: global___KeyLocator | None = ...,
        all_signer_pubkeys: collections.abc.Iterable[builtins.bytes] | None = ...,
        other_signer_public_nonces: collections.abc.Iterable[builtins.bytes] | None = ...,
        tweaks: collections.abc.Iterable[global___TweakDesc] | None = ...,
        taproot_tweak: global___TaprootTweakDesc | None = ...,
        version: global___MuSig2Version.ValueType = ...,
        pregenerated_local_nonce: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_loc", b"key_loc", "taproot_tweak", b"taproot_tweak"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["all_signer_pubkeys", b"all_signer_pubkeys", "key_loc", b"key_loc", "other_signer_public_nonces", b"other_signer_public_nonces", "pregenerated_local_nonce", b"pregenerated_local_nonce", "taproot_tweak", b"taproot_tweak", "tweaks", b"tweaks", "version", b"version"]) -> None: ...

global___MuSig2SessionRequest = MuSig2SessionRequest

@typing.final
class MuSig2SessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_ID_FIELD_NUMBER: builtins.int
    COMBINED_KEY_FIELD_NUMBER: builtins.int
    TAPROOT_INTERNAL_KEY_FIELD_NUMBER: builtins.int
    LOCAL_PUBLIC_NONCES_FIELD_NUMBER: builtins.int
    HAVE_ALL_NONCES_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    session_id: builtins.bytes
    """
    The unique ID that represents this signing session. A session can be used
    for producing a signature a single time. If the signing fails for any
    reason, a new session with the same participants needs to be created.
    """
    combined_key: builtins.bytes
    """
    The combined public key (in the 32-byte x-only format) with all tweaks
    applied to it. If a taproot tweak is specified, this corresponds to the
    taproot key that can be put into the on-chain output.
    """
    taproot_internal_key: builtins.bytes
    """
    The raw combined public key (in the 32-byte x-only format) before any tweaks
    are applied to it. If a taproot tweak is specified, this corresponds to the
    internal key that needs to be put into the witness if the script spend path
    is used.
    """
    local_public_nonces: builtins.bytes
    """
    The two public nonces the local signer uses, combined into a single value
    of 66 bytes. Can be split into the two 33-byte points to get the individual
    nonces.
    """
    have_all_nonces: builtins.bool
    """
    Indicates whether all nonces required to start the signing process are known
    now.
    """
    version: global___MuSig2Version.ValueType
    """
    The version of the MuSig2 BIP that was used to create the session.
    """
    def __init__(
        self,
        *,
        session_id: builtins.bytes = ...,
        combined_key: builtins.bytes = ...,
        taproot_internal_key: builtins.bytes = ...,
        local_public_nonces: builtins.bytes = ...,
        have_all_nonces: builtins.bool = ...,
        version: global___MuSig2Version.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["combined_key", b"combined_key", "have_all_nonces", b"have_all_nonces", "local_public_nonces", b"local_public_nonces", "session_id", b"session_id", "taproot_internal_key", b"taproot_internal_key", "version", b"version"]) -> None: ...

global___MuSig2SessionResponse = MuSig2SessionResponse

@typing.final
class MuSig2RegisterNoncesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_ID_FIELD_NUMBER: builtins.int
    OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER: builtins.int
    session_id: builtins.bytes
    """
    The unique ID of the signing session those nonces should be registered with.
    """
    @property
    def other_signer_public_nonces(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        A list of all public nonces of other signing participants that should be
        registered.
        """

    def __init__(
        self,
        *,
        session_id: builtins.bytes = ...,
        other_signer_public_nonces: collections.abc.Iterable[builtins.bytes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["other_signer_public_nonces", b"other_signer_public_nonces", "session_id", b"session_id"]) -> None: ...

global___MuSig2RegisterNoncesRequest = MuSig2RegisterNoncesRequest

@typing.final
class MuSig2RegisterNoncesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HAVE_ALL_NONCES_FIELD_NUMBER: builtins.int
    have_all_nonces: builtins.bool
    """
    Indicates whether all nonces required to start the signing process are known
    now.
    """
    def __init__(
        self,
        *,
        have_all_nonces: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["have_all_nonces", b"have_all_nonces"]) -> None: ...

global___MuSig2RegisterNoncesResponse = MuSig2RegisterNoncesResponse

@typing.final
class MuSig2SignRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_ID_FIELD_NUMBER: builtins.int
    MESSAGE_DIGEST_FIELD_NUMBER: builtins.int
    CLEANUP_FIELD_NUMBER: builtins.int
    session_id: builtins.bytes
    """
    The unique ID of the signing session to use for signing.
    """
    message_digest: builtins.bytes
    """
    The 32-byte SHA256 digest of the message to sign.
    """
    cleanup: builtins.bool
    """
    Cleanup indicates that after signing, the session state can be cleaned up,
    since another participant is going to be responsible for combining the
    partial signatures.
    """
    def __init__(
        self,
        *,
        session_id: builtins.bytes = ...,
        message_digest: builtins.bytes = ...,
        cleanup: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["cleanup", b"cleanup", "message_digest", b"message_digest", "session_id", b"session_id"]) -> None: ...

global___MuSig2SignRequest = MuSig2SignRequest

@typing.final
class MuSig2SignResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCAL_PARTIAL_SIGNATURE_FIELD_NUMBER: builtins.int
    local_partial_signature: builtins.bytes
    """
    The partial signature created by the local signer.
    """
    def __init__(
        self,
        *,
        local_partial_signature: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["local_partial_signature", b"local_partial_signature"]) -> None: ...

global___MuSig2SignResponse = MuSig2SignResponse

@typing.final
class MuSig2CombineSigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_ID_FIELD_NUMBER: builtins.int
    OTHER_PARTIAL_SIGNATURES_FIELD_NUMBER: builtins.int
    session_id: builtins.bytes
    """
    The unique ID of the signing session to combine the signatures for.
    """
    @property
    def other_partial_signatures(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """
        The list of all other participants' partial signatures to add to the current
        session.
        """

    def __init__(
        self,
        *,
        session_id: builtins.bytes = ...,
        other_partial_signatures: collections.abc.Iterable[builtins.bytes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["other_partial_signatures", b"other_partial_signatures", "session_id", b"session_id"]) -> None: ...

global___MuSig2CombineSigRequest = MuSig2CombineSigRequest

@typing.final
class MuSig2CombineSigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HAVE_ALL_SIGNATURES_FIELD_NUMBER: builtins.int
    FINAL_SIGNATURE_FIELD_NUMBER: builtins.int
    have_all_signatures: builtins.bool
    """
    Indicates whether all partial signatures required to create a final, full
    signature are known yet. If this is true, then the final_signature field is
    set, otherwise it is empty.
    """
    final_signature: builtins.bytes
    """
    The final, full signature that is valid for the combined public key.
    """
    def __init__(
        self,
        *,
        have_all_signatures: builtins.bool = ...,
        final_signature: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["final_signature", b"final_signature", "have_all_signatures", b"have_all_signatures"]) -> None: ...

global___MuSig2CombineSigResponse = MuSig2CombineSigResponse

@typing.final
class MuSig2CleanupRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_ID_FIELD_NUMBER: builtins.int
    session_id: builtins.bytes
    """
    The unique ID of the signing session that should be removed/cleaned up.
    """
    def __init__(
        self,
        *,
        session_id: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["session_id", b"session_id"]) -> None: ...

global___MuSig2CleanupRequest = MuSig2CleanupRequest

@typing.final
class MuSig2CleanupResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___MuSig2CleanupResponse = MuSig2CleanupResponse
